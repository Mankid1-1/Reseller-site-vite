import 'dotenv/config';
import pg from 'pg';

const { Pool } = pg;

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.DATABASE_URL?.includes('sslmode=require') ? { rejectUnauthorized: false } : undefined,
});

const WORKER_ID = process.env.WORKER_ID || `termux-${process.pid}`;
const POLL_MS = Number(process.env.JOB_POLL_MS || 1000);
const BATCH = Number(process.env.JOB_BATCH || 10);

const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

async function claimJobs(client) {
  const q = `
    with cte as (
      select id
      from jobs
      where status = 'queued'
        and run_at <= now()
      order by run_at asc
      for update skip locked
      limit $1
    )
    update jobs j
    set status='running', locked_at=now(), locked_by=$2, attempts = attempts + 1
    from cte
    where j.id = cte.id
    returning j.*;
  `;
  const { rows } = await client.query(q, [BATCH, WORKER_ID]);
  return rows;
}

async function upsertAttempt(client, jobId, attemptNo, status, error = null) {
  if (status === 'started') {
    await client.query(
      `insert into job_attempts(job_id, attempt_no, status) values ($1,$2,'started')`,
      [jobId, attemptNo]
    );
    return;
  }
  await client.query(
    `update job_attempts
     set status=$3, error=$4, finished_at=now()
     where job_id=$1 and attempt_no=$2 and status='started'`,
    [jobId, attemptNo, status, error]
  );
}

async function succeedJob(client, jobId) {
  await client.query(`update jobs set status='succeeded', last_error=null where id=$1`, [jobId]);
}

async function failJob(client, jobId, err) {
  const { rows } = await client.query(`select attempts from jobs where id=$1`, [jobId]);
  const attempts = rows[0]?.attempts ?? 1;
  const dead = attempts >= 5;

  const backoffSeconds = Math.min(60 * 30, Math.pow(2, attempts) * 5);
  await client.query(
    `update jobs
     set status=$2,
         last_error=$3,
         run_at = case when $2='queued' then now() + ($4 || ' seconds')::interval else run_at end
     where id=$1`,
    [jobId, dead ? 'dead' : 'queued', String(err?.stack || err), String(backoffSeconds)]
  );
}

async function handleGapFill(client, job) {
  const p = job.payload || {};
  const tenantId = job.tenant_id;

  const { rows: candidates } = await client.query(
    `
    select w.*, c.phone, c.email, c.full_name
    from waitlist_entries w
    left join customers c on c.id = w.customer_id
    where w.tenant_id = $1
      and w.status = 'active'
      and (w.earliest_ts is null or w.earliest_ts <= $2::timestamptz)
      and (w.latest_ts is null or w.latest_ts >= $3::timestamptz)
      and ($4::uuid is null or w.desired_service_id = $4::uuid)
    order by w.priority_score desc, w.created_at asc
    limit 5
    `,
    [tenantId, p.gap_start, p.gap_end, p.service_id || null]
  );

  if (!candidates.length) return;

  const top = candidates[0];
  await client.query(`update waitlist_entries set status='contacted' where id=$1`, [top.id]);

  const body = `A slot opened up. Reply YES to book. Window: ${p.gap_start} - ${p.gap_end}`;
  if (top.phone) {
    await client.query(
      `insert into messages(tenant_id, channel, "to", body, status) values ($1,'sms',$2,$3,'queued')`,
      [tenantId, top.phone, body]
    );
  } else if (top.email) {
    await client.query(
      `insert into messages(tenant_id, channel, "to", body, status) values ($1,'email',$2,$3,'queued')`,
      [tenantId, top.email, body]
    );
  }
}

async function handleJob(client, job) {
  switch (job.type) {
    case 'gap_fill':
      return handleGapFill(client, job);
    default:
      return;
  }
}

async function loop() {
  while (true) {
    const client = await pool.connect();
    try {
      await client.query('begin');
      const jobs = await claimJobs(client);

      for (const job of jobs) {
        const attemptNo = job.attempts;
        await upsertAttempt(client, job.id, attemptNo, 'started');
        try {
          await handleJob(client, job);
          await succeedJob(client, job.id);
          await upsertAttempt(client, job.id, attemptNo, 'succeeded');
        } catch (e) {
          await upsertAttempt(client, job.id, attemptNo, 'failed', String(e?.stack || e));
          await failJob(client, job.id, e);
        }
      }

      await client.query('commit');
    } catch {
      try { await client.query('rollback'); } catch {}
    } finally {
      client.release();
    }
    await sleep(POLL_MS);
  }
}

loop().catch((e) => {
  console.error(e);
  process.exit(1);
});
